{"meta":{"title":"Blog","subtitle":null,"description":null,"author":"Bill","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"leetcode简单 104","slug":"leetcode简单-104","date":"2019-04-05T05:56:04.000Z","updated":"2019-04-05T05:56:55.567Z","comments":true,"path":"2019/04/05/leetcode简单-104/","link":"","permalink":"http://yoursite.com/2019/04/05/leetcode简单-104/","excerpt":"","text":"这个题已经写了好几遍了，就是求二叉树的高度的问题。一定要背下来。经常考。12345678910111213141516171819class Solution &#123;public: int maxDepth(TreeNode* root) &#123; // 如果root为空 if (root == NULL) &#123; return 0; &#125; if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123; return 1; &#125; return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)); &#125;&#125;;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"leetcode简单","slug":"leetcode简单","permalink":"http://yoursite.com/tags/leetcode简单/"}]},{"title":"leetcode简单 237","slug":"leetcode简单-237","date":"2019-04-05T05:49:33.000Z","updated":"2019-04-05T05:51:20.136Z","comments":true,"path":"2019/04/05/leetcode简单-237/","link":"","permalink":"http://yoursite.com/2019/04/05/leetcode简单-237/","excerpt":"","text":"这个题在剑指offer上出现过。就是把后一个节点的值复制到当前节点，然后把后一个节点删掉。leetcode上free的话好像会报错，就省了。代码就两行。 12345678910111213class Solution &#123;public: void deleteNode(ListNode* node) &#123; node-&gt;val = node-&gt;next-&gt;val; node-&gt;next = node-&gt;next-&gt;next; //ListNode *next= node-&gt;next; //free(next); &#125;&#125;;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"leetcode简单","slug":"leetcode简单","permalink":"http://yoursite.com/tags/leetcode简单/"}]},{"title":"leetcode简单 709","slug":"leetcode简单-709","date":"2019-04-05T05:35:10.000Z","updated":"2019-04-05T05:35:54.427Z","comments":true,"path":"2019/04/05/leetcode简单-709/","link":"","permalink":"http://yoursite.com/2019/04/05/leetcode简单-709/","excerpt":"","text":"这个题直接暴力循环就能过 12345678910111213141516171819class Solution &#123;public: string toLowerCase(string str) &#123; string result = \"\"; for (int i = 0; i &lt; str.size(); i++) &#123; if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') &#123; result += ('a' + str[i] - 'A'); &#125; else &#123; result += str[i]; &#125; &#125; return result; &#125;&#125;;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"leetcode简单","slug":"leetcode简单","permalink":"http://yoursite.com/tags/leetcode简单/"}]},{"title":"leetcode简单 771","slug":"leetcode简单-771","date":"2019-04-05T05:28:32.000Z","updated":"2019-04-05T05:31:15.069Z","comments":true,"path":"2019/04/05/leetcode简单-771/","link":"","permalink":"http://yoursite.com/2019/04/05/leetcode简单-771/","excerpt":"","text":"暴力求解法， 两个循环，复杂度$O(n^2)$ 1234567891011121314151617181920class Solution &#123;public: int numJewelsInStones(string J, string S) &#123; int lenJ = J.size(); int lenS = S.size(); int count = 0; for (int i = 0; i &lt; lenS; i++) &#123; for (int j = 0; j &lt; lenJ; j++) &#123; if (S[i] == J[j]) &#123; count++; &#125; &#125; &#125; return count; &#125;&#125;;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"leetcode简单","slug":"leetcode简单","permalink":"http://yoursite.com/tags/leetcode简单/"}]},{"title":"基础堆算法","slug":"基础堆算法","date":"2019-04-05T04:54:44.000Z","updated":"2019-04-05T04:58:08.117Z","comments":true,"path":"2019/04/05/基础堆算法/","link":"","permalink":"http://yoursite.com/2019/04/05/基础堆算法/","excerpt":"","text":"1234567891011121314151617181920212223void heapify(int arr[], int n, int i) &#123; int largest = i; // Initialize largest as root int l = 2*i + 1; // left = 2*i + 1 int r = 2*i + 2; // right = 2*i + 2 // If left child is larger than root if (l &lt; n &amp;&amp; arr[l] &gt; arr[largest]) largest = l; // If right child is larger than largest so far if (r &lt; n &amp;&amp; arr[r] &gt; arr[largest]) largest = r; // If largest is not root if (largest != i) &#123; swap(arr[i], arr[largest]); // Recursively heapify the affected sub-tree heapify(arr, n, largest); &#125; &#125; 12345void buildHeap(int arr[], int n) &#123; // Build heap (rearrange array) for (int i = n / 2 - 1; i &gt;= 0; i--) heapify(arr, n, i); &#125; 123456789101112131415// main function to do heap sort void heapSort(int arr[], int n) &#123; buildHeap(arr, n); // One by one extract an element from heap for (int i=n-1; i&gt;=0; i--) &#123; // Move current root to end swap(arr[0], arr[i]); // call max heapify on the reduced heap heapify(arr, i, 0); &#125; &#125; 掌握了这3段程序就能写出堆排序的程序了。","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"binary search template","slug":"binary-search-template","date":"2019-04-04T05:28:21.000Z","updated":"2019-04-04T07:34:56.543Z","comments":true,"path":"2019/04/04/binary-search-template/","link":"","permalink":"http://yoursite.com/2019/04/04/binary-search-template/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: /** * @param nums: The integer array. * @param target: Target to find. * @return: The first position of target. Position starts from 0. */ int binarySearch(vector&lt;int&gt; &amp;nums, int target) &#123; // write your code here if (nums.size() == 0) &#123; return -1; &#125; int start = 0; int end = nums.size() - 1; int mid; while (start + 1 &lt; end) &#123; mid = start + (end - start) / 2; if (nums[mid] == target) &#123; end = mid; &#125; else if (nums[mid] &lt; target) &#123; start = mid; &#125; else if (nums[mid] &gt; target) &#123; end = mid; &#125; &#125; if (nums[start] == target) &#123; return start; &#125; if (nums[end] == target) &#123; return end; &#125; return -1; &#125;&#125;;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"二分查找","slug":"二分查找","permalink":"http://yoursite.com/tags/二分查找/"},{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"}]},{"title":"class Solution {","slug":"class-Solution","date":"2019-04-04T05:27:59.000Z","updated":"2019-04-04T05:27:59.244Z","comments":true,"path":"2019/04/04/class-Solution/","link":"","permalink":"http://yoursite.com/2019/04/04/class-Solution/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-04-04T04:28:25.009Z","updated":"2019-04-05T05:56:58.239Z","comments":true,"path":"2019/04/04/hello-world/","link":"","permalink":"http://yoursite.com/2019/04/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"print char if not told how many","slug":"print-char-if-not-told-how-many","date":"2019-04-03T09:21:37.000Z","updated":"2019-04-04T04:37:24.908Z","comments":true,"path":"2019/04/03/print-char-if-not-told-how-many/","link":"","permalink":"http://yoursite.com/2019/04/03/print-char-if-not-told-how-many/","excerpt":"","text":"链接：https://ac.nowcoder.com/acm/problem/22224来源：牛客网 题目描述输入一行字符串，原样输出这个字符串。 输入描述:输入一行，包含一个字符串。输出描述:输出一个字符串。示例1输入复制oi er输出复制oi er 1234567891011121314#include &lt;cstdio&gt;#include &lt;cstring&gt;int main() &#123; // freopen(\"input.txt\", \"r\", stdin); int c; while ((c = getchar()) != EOF) &#123; printf(\"%c\", c); &#125; return 0;&#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"NOIP普及组","slug":"NOIP普及组","permalink":"http://yoursite.com/tags/NOIP普及组/"}]},{"title":"输出金字塔图形","slug":"输出金字塔图形","date":"2019-04-01T06:06:23.000Z","updated":"2019-04-01T06:14:26.000Z","comments":true,"path":"2019/04/01/输出金字塔图形/","link":"","permalink":"http://yoursite.com/2019/04/01/输出金字塔图形/","excerpt":"","text":"这种题应该先想办法输出 * * * * * * * * * * * * * * * * * * * * * * * * * 这种靠一边的，然后再加空格变成 * * * * * * * * * * * * * * * * * * * * * * * * * 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;int main() &#123; //freopen(\"input.txt\", \"r\", stdin); int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; /*for (int j = 0; j &lt; n - i - 1; j++) &#123; printf(\" \"); &#125;*/ for (int j = 0; j &lt; n - i - 1; j++) &#123; printf(\" \"); &#125; for (int j = 0; j &lt;2 * i + 1; j++) &#123; printf(\"*\"); &#125; printf(\"\\n\"); &#125; return 0;&#125; 如果是输出双层金字塔 * *** ***** ******* ********* ******* ***** *** * 那么我们先输出 * * * * * * * * * * * * * * * * * * * * * * * * * 然后再输出 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 然后再增加空格 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 然后稍微改一下就可以变成目标形状 * *** ***** ******* ********* ******* ***** *** * 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;int main() &#123; //freopen(\"input.txt\", \"r\", stdin); int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n - i - 1; j++) &#123; printf(\" \"); &#125; for (int j = 0; j &lt;2 * i + 1; j++) &#123; printf(\"*\"); &#125; printf(\"\\n\"); &#125; for (int i = n - 2; i &gt; -1; i--) &#123; for (int j = 0; j &lt; n - i - 1; j++) &#123; printf(\" \"); &#125; for (int j = 0; j &lt;2 * i + 1; j++) &#123; printf(\"*\"); &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"Algorithm NOIP普及组","slug":"Algorithm-NOIP普及组","permalink":"http://yoursite.com/tags/Algorithm-NOIP普及组/"}]},{"title":"选村长","slug":"选村长","date":"2019-04-01T05:34:29.000Z","updated":"2019-04-01T05:36:15.000Z","comments":true,"path":"2019/04/01/选村长/","link":"","permalink":"http://yoursite.com/2019/04/01/选村长/","excerpt":"","text":"题目描述牛村正在进行村长选举，投票人一人一票，牛可乐是候选人A（投票代号为1）、牛能是候选人B（投票代号为2）和牛妹是候选人C（投票代号为3），其他投票代号无效。投票列表用以-1表示结束，请分别统计出他们的得票数。谁的得票超过全部投票人数的半数，就输出谁当选为村长，如“A-yes”表示A当选，全部不过半数，输出“all-NO”。 输入描述:输入一行，若干个整数，以-1结尾 输出描述:输出五行，前三行表示三个候选人的表票数，然后是总的有效票数，最后一行表示选举结果。 示例输入 1 1 3 2 1 3 2 1 3 3 1 2 4 1 4 1 2 1 2 1 1 -1 输出 A=10 B=5 C=4 Tot=19 all-NO 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cmath&gt;int main() &#123;// freopen(\"input.txt\", \"r\", stdin); int c; int A = 0, B = 0, C = 0, Tot = 0; while ((c = getchar()) != '-') &#123; //printf(\"%c\", c); if (c == '1') &#123; A += 1; Tot += 1; &#125; if (c == '2') &#123; B += 1; Tot += 1; &#125; if (c == '3') &#123; C += 1; Tot += 1; &#125; &#125; printf(\"A=%d\\n\", A); printf(\"B=%d\\n\", B); printf(\"C=%d\\n\", C); printf(\"Tot=%d\\n\", Tot); if (A &gt; ceil(Tot / 2.0)) &#123; printf(\"A-yes\\n\"); &#125; else if (B &gt; ceil(Tot / 2.0)) &#123; printf(\"B-yes\\n\"); &#125; else if (C &gt; ceil(Tot / 2.0)) &#123; printf(\"C-yes\\n\"); &#125; else &#123; printf(\"all-NO\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"Algorithm NOIP普及组","slug":"Algorithm-NOIP普及组","permalink":"http://yoursite.com/tags/Algorithm-NOIP普及组/"}]},{"title":"n元人民币换成1元2元5元的零钱共有多少种兑换方法","slug":"n元人民币换成1元2元5元的零钱共有多少种兑换方法","date":"2019-04-01T04:57:31.000Z","updated":"2019-04-04T05:01:44.549Z","comments":true,"path":"2019/04/01/n元人民币换成1元2元5元的零钱共有多少种兑换方法/","link":"","permalink":"http://yoursite.com/2019/04/01/n元人民币换成1元2元5元的零钱共有多少种兑换方法/","excerpt":"","text":"链接：https://ac.nowcoder.com/acm/problem/22214来源：牛客网 牛可乐在牛牛商场买了一个帽子，要支付c元金币，牛牛商场一律不找零钱，牛可乐手里有不限数量的面值a元的金币和面值b元的金币，请问牛可乐可以用金币刚好凑出总价c元吗？ 123456789101112131415161718192021#include &lt;cstdio&gt;int main() &#123; int n; scanf(\"%d\", &amp;n); int sum = 0; for (int i = 0; i &lt;= n / 2; i++) &#123; for (int j = 0; j &lt;= n / 5; j++) &#123; if (n - i * 2 - j * 5 &gt;= 0) &#123; sum += 1; &#125; &#125; &#125; printf(\"%d\\n\", sum); return 0;&#125; 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cmath&gt;int Is(int a, int b, int c) &#123; int ceilA = ceil(c * 1.0 / a); int ceilB = ceil(c * 1.0 / b); for (int i = 0; i &lt;= ceilA; i++) &#123; for (int j = 0; j &lt;= ceilB; j++) &#123; if (i * a + j * b == c) &#123; return 1; &#125; &#125; &#125; return 0;&#125;int main() &#123; int a, b, c; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); if (Is(a, b, c)) &#123; printf(\"Yes\\n\"); &#125; else &#123; printf(\"No\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"NOIP普及组","slug":"NOIP普及组","permalink":"http://yoursite.com/tags/NOIP普及组/"}]},{"title":"Sum of all proper divisors of a natural number","slug":"Sum-of-all-proper-divisors-of-a-natural-number","date":"2019-04-01T04:50:22.000Z","updated":"2019-04-01T06:45:27.000Z","comments":true,"path":"2019/04/01/Sum-of-all-proper-divisors-of-a-natural-number/","link":"","permalink":"http://yoursite.com/2019/04/01/Sum-of-all-proper-divisors-of-a-natural-number/","excerpt":"","text":"Given a natural number, calculate sum of all its proper divisors. A proper divisor of a natural number is the divisor that is strictly less than the number. For example, number 20 has 5 proper divisors: 1, 2, 4, 5, 10, and the divisor summation is: 1 + 2 + 4 + 5 + 10 = 22. Examples : Input : num = 10 Output: 8 // proper divisors 1 + 2 + 5 = 8 Input : num = 36 Output: 55 // proper divisors 1 + 2 + 3 + 4 + 6 + 9 + 12 + 18 = 55 This problem has very simple solution, we all know that for any number ‘num’ all its divisors are always less than and equal to ‘num/2’ and all prime factors are always less than and equal to sqrt(num). So we iterate through ‘i’ till i&lt;=sqrt(num) and for any ‘i’ if it divides ‘num’ , then we get two divisors ‘i’ and ‘num/i’ , continuously add these divisors but for some numbers divisors ‘i’ and ‘num/i’ will same in this case just add only one divisor , e.g; num=36 so for i=6 we will get (num/i)=6 , that’s why we will at 6 in the summation only once. Finally we add one as one is divisor of all natural numbers. 1234567891011121314151617181920212223242526272829303132333435363738// C++ program to find sum of all divisors of // a natural number #include&lt;bits/stdc++.h&gt; using namespace std; // Function to calculate sum of all proper divisors // num --&gt; given natural number int divSum(int num) &#123; // Final result of summation of divisors int result = 0; // find all divisors which divides 'num' for (int i=2; i&lt;=sqrt(num); i++) &#123; // if 'i' is divisor of 'num' if (num%i==0) &#123; // if both divisors are same then add // it only once else add both if (i==(num/i)) result += i; else result += (i + num/i); &#125; &#125; // Add 1 to the result as 1 is also a divisor return (result + 1); &#125; // Driver program to run the case int main() &#123; int num = 36; cout &lt;&lt; divSum(num); return 0; &#125; 牛村村口要架设一个矩形的广告屏，村长要求广告屏的总像素必须为n，还要求广告屏的长和宽最大可能的接近，而且宽不能大于长，村长找你来计算一下宽和长分别为多少？ 1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = sqrt(n); i &gt;= 1; i--) &#123; if (n % i == 0) &#123; printf(\"%d %d\\n\", i, n / i); break; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"Algorithm NOIP普及组","slug":"Algorithm-NOIP普及组","permalink":"http://yoursite.com/tags/Algorithm-NOIP普及组/"}]},{"title":"能被3整除且至少有一位数字是5","slug":"能被3整除且至少有一位数字是5","date":"2019-04-01T04:37:15.000Z","updated":"2019-04-01T04:38:47.000Z","comments":true,"path":"2019/04/01/能被3整除且至少有一位数字是5/","link":"","permalink":"http://yoursite.com/2019/04/01/能被3整除且至少有一位数字是5/","excerpt":"","text":"题目描述输出1~n中能被3整除，且至少有一位数字是5的所有整数. 输入描述:输入一行，包含一个整数n。(1 &lt;= n &lt;= 100000) 示例1输入 50 输出 15 45 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int gewei = i % 10; int shiwei = (i / 10) % 10; int baiwei = (i / 100) % 10; int qianwei = (i / 1000) % 10; int wanwei = (i / 10000) % 10; int shiwanwei = (i / 100000) % 10; if ( (i % 3 == 0) &amp;&amp; ( gewei == 5 || shiwei == 5 || baiwei == 5 || qianwei == 5 || wanwei == 5 || shiwanwei == 5 ) ) &#123; printf(\"%d\\n\", i); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"Algorithm NOIP普及组","slug":"Algorithm-NOIP普及组","permalink":"http://yoursite.com/tags/Algorithm-NOIP普及组/"}]},{"title":"判断回文数","slug":"判断回文数","date":"2019-04-01T04:27:08.000Z","updated":"2019-04-01T04:28:57.000Z","comments":true,"path":"2019/04/01/判断回文数/","link":"","permalink":"http://yoursite.com/2019/04/01/判断回文数/","excerpt":"","text":"判断一个数是否为回文数。 设n是一任意自然数。若将n的各位数字反向排列所得自然数n1与n相等，则称n为一回文数。例如，若n=1234321，则称n为一回文数；但若n=1234567，则n不是回文数 实例 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt; int main()&#123; int n, reversedInteger = 0, remainder, originalInteger; printf(\"输入一个整数: \"); scanf(\"%d\", &amp;n); originalInteger = n; // 翻转 while( n!=0 ) &#123; remainder = n%10; reversedInteger = reversedInteger*10 + remainder; n /= 10; &#125; // 判断 if (originalInteger == reversedInteger) printf(\"%d 是回文数。\", originalInteger); else printf(\"%d 不是回文数。\", originalInteger); return 0;&#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"判断数字是几位数","slug":"判断数字是几位数","date":"2019-04-01T04:13:54.000Z","updated":"2019-04-01T04:29:08.000Z","comments":true,"path":"2019/04/01/判断数字是几位数/","link":"","permalink":"http://yoursite.com/2019/04/01/判断数字是几位数/","excerpt":"","text":"用户输入数字，判断该数字是几位数。 实例 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; long long n; int count = 0; printf(\"输入一个整数: \"); scanf(\"%lld\", &amp;n); while(n != 0) &#123; // n = n/10 n /= 10; ++count; &#125; printf(\"数字是 %d 位数。\", count);&#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"Greatest Common Divisor Algorithm","slug":"Greatest-Common-Divisor-Algorithm-md","date":"2019-03-30T19:20:24.000Z","updated":"2019-03-30T19:36:07.000Z","comments":true,"path":"2019/03/31/Greatest-Common-Divisor-Algorithm-md/","link":"","permalink":"http://yoursite.com/2019/03/31/Greatest-Common-Divisor-Algorithm-md/","excerpt":"","text":"Greatest Common Divisor Algorithm#include &lt;cstdio&gt; int gcd(int a, int b) { int c = a % b; if (c != 0) { return gcd(b, c); } else { return b; } } int main() { int a, b; scanf(\"%d %d\", &amp;a, &amp;b); if (a &gt;= b) { printf(\"%d\\n\", gcd(a, b)); } else { printf(\"%d\\n\", gcd(b, a)); } return 0; }","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"}]},{"title":"Whether a binary tree is balanced or not.md","slug":"Whether-a-binary-tree-is-balanced-or-not-md","date":"2019-03-30T18:40:55.000Z","updated":"2019-03-30T18:51:43.000Z","comments":true,"path":"2019/03/31/Whether-a-binary-tree-is-balanced-or-not-md/","link":"","permalink":"http://yoursite.com/2019/03/31/Whether-a-binary-tree-is-balanced-or-not-md/","excerpt":"","text":"Whether a binary tree is balanced or notThe definition of a balanced binary tree is : left sub-tree is balanced &amp;&amp; right sub-tree is balanced &amp;&amp; abs(height(left) - height(right)) &lt;= 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/* CPP program to check if a tree is height-balanced or not */#include &lt;bits/stdc++.h&gt; using namespace std; /* A binary tree node has data, pointer to left child and a pointer to right child */class node &#123; public: int data; node* left; node* right; &#125;; /* Returns the height of a binary tree */int height(node* node); /* Returns true if binary tree with root as root is height-balanced */bool isBalanced(node *root) &#123; int lh; /* for height of left subtree */ int rh; /* for height of right subtree */ /* If tree is empty then return true */ if(root == NULL) return 1; /* Get the height of left and right sub trees */ lh = height(root-&gt;left); rh = height(root-&gt;right); if( abs(lh-rh) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right)) return 1; /* If we reach here then tree is not height-balanced */ return 0; &#125; /* UTILITY FUNCTIONS TO TEST isBalanced() FUNCTION *//* returns maximum of two integers */int max(int a, int b) &#123; return (a &gt;= b)? a: b; &#125; /* The function Compute the \"height\" of a tree. Height is the number of nodes along the longest path from the root node down to the farthest leaf node.*/int height(node* node) &#123; /* base case tree is empty */ if(node == NULL) return 0; /* If tree is not empty then height = 1 + max of left height and right heights */ return 1 + max(height(node-&gt;left), height(node-&gt;right)); &#125; /* Helper function that allocates a new node with the given data and NULL left and right pointers. */node* newNode(int data) &#123; node* Node = new node(); Node-&gt;data = data; Node-&gt;left = NULL; Node-&gt;right = NULL; return(Node); &#125; // Driver code int main() &#123; node *root = newNode(1); root-&gt;left = newNode(2); root-&gt;right = newNode(3); root-&gt;left-&gt;left = newNode(4); root-&gt;left-&gt;right = newNode(5); root-&gt;left-&gt;left-&gt;left = newNode(8); if(isBalanced(root)) cout &lt;&lt; \"Tree is balanced\"; else cout &lt;&lt; \"Tree is not balanced\"; return 0; &#125; // This code is contributed by rathbhupendra","categories":[],"tags":[]},{"title":"How to publish my writing.md","slug":"How-to-publish-my-writing-md","date":"2019-03-30T18:32:34.000Z","updated":"2019-03-30T19:00:02.000Z","comments":true,"path":"2019/03/31/How-to-publish-my-writing-md/","link":"","permalink":"http://yoursite.com/2019/03/31/How-to-publish-my-writing-md/","excerpt":"","text":"How to Publish My Writing Next TimeFirst, type in 1sudo hexo new \"How to * .md\" then in folder /source/_posts/ we can see our newly generated markdown file. Then open and edit it. After editing, type in 1sudo hexo clean &amp;&amp; hexo g g standards for generate Then in order to preview, we can type in 1sudo hexo server -p 8080 p standards for port then we can preview in our browser. If it is ok, we can type in 1sudo hexo d d standards for deploy to publish it.","categories":[],"tags":[]}]}