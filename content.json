{"meta":{"title":"Blog","subtitle":null,"description":null,"author":"Bill","url":"http://yoursite.com/blog","root":"/blog/"},"pages":[],"posts":[{"title":"反转链表返回表头","slug":"反转链表返回表头","date":"2019-04-14T05:37:30.000Z","updated":"2019-04-14T05:40:36.000Z","comments":true,"path":"2019/04/14/反转链表返回表头/","link":"","permalink":"http://yoursite.com/blog/2019/04/14/反转链表返回表头/","excerpt":"","text":"输入一个链表，反转链表后，输出新链表的表头。 这个题比较复杂。我先背下来吧。暂时理解不了。 geeksforgeeks上有讲解，感觉太费脑子了。地址在这里https://www.geeksforgeeks.org/reverse-a-linked-list/ 伪代码表示如下123456789101112Initialize three pointers prev as NULL, curr as head and next as NULL.Iterate trough the linked list. In loop, do following.// Before changing next of current,// store next nodenext = curr-&gt;next// Now change next of current// This is where actual reversing happenscurr-&gt;next = prev// Move prev and curr one step forwardprev = currcurr = next 1234567891011121314151617181920212223/* Function to reverse the linked list */ void reverse() &#123; // Initialize current, previous and // next pointers Node *current = head; Node *prev = NULL, *next = NULL; while (current != NULL) &#123; // Store next next = current-&gt;next; // Reverse current node's pointer current-&gt;next = prev; // Move pointers one position ahead. prev = current; current = next; &#125; head = prev; &#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/blog/tags/Algorithm/"},{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/blog/tags/剑指offer/"},{"name":"LinkedList","slug":"LinkedList","permalink":"http://yoursite.com/blog/tags/LinkedList/"}]},{"title":"两个栈实现队列","slug":"两个栈实现队列","date":"2019-04-14T05:11:01.000Z","updated":"2019-04-14T05:16:42.343Z","comments":true,"path":"2019/04/14/两个栈实现队列/","link":"","permalink":"http://yoursite.com/blog/2019/04/14/两个栈实现队列/","excerpt":"","text":"两个栈实现队列的push：首先把stack1中的元素都搬到stack2中去，然后再把新元素放到stack1中。 1234567891011void push(int node) &#123; while (!stack1.empty()) &#123; stack2.push(stack1.top()); stack1.pop(); &#125; stack1.push(node); while (!stack2.empty()) &#123; stack1.push(stack2.top()); stack2.pop(); &#125; &#125; 即队列的tail指针在栈尾，head指针在栈顶。 实现队列的pop队列就是stack1，拿到stack1的栈顶元素，然后弹出一个元素。 123456int pop() &#123; int result = stack1.top(); stack1.pop(); return result; &#125; 其他要注意的获得栈顶元素用1int stack.top(); // 返回栈顶元素的值 弹出栈顶元素用1void stack.pop(); // 没有返回值","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/blog/tags/Algorithm/"},{"name":"stack","slug":"stack","permalink":"http://yoursite.com/blog/tags/stack/"},{"name":"queue","slug":"queue","permalink":"http://yoursite.com/blog/tags/queue/"},{"name":"剑指offer","slug":"剑指offer","permalink":"http://yoursite.com/blog/tags/剑指offer/"}]},{"title":"Java 中面向对象与内存解析","slug":"Java-中面向对象与内存解析","date":"2019-04-12T09:35:32.000Z","updated":"2019-04-14T05:17:40.553Z","comments":true,"path":"2019/04/12/Java-中面向对象与内存解析/","link":"","permalink":"http://yoursite.com/blog/2019/04/12/Java-中面向对象与内存解析/","excerpt":"","text":"Java中局部变量i必须要初始化，否则javac编译时报错；成员变量（一个类的private成员）可以不初始化，默认分配为012345678910public class Dog &#123; static int age; public static void main(String[] args) &#123; int i; System.out.println(i); //报错，i没有有初始化 System.out.println(age); //输出0 &#125;&#125; 堆内存装着所有new出来的东西堆内存是动态分配内存的。 敲javac是编译期间，敲java是运行期间。 内存有4块：code，data，stack，heap 类是静态的概念，位于代码区。 123456789class C &#123; int i; int j; public static void main(String[] args) &#123; C c1 = new C(); // C c1定义了一个局部变量，所以在stack里面。new出来的东西分配在heap里面 C c2 = new C(); &#125;&#125; 静态变量static存放在数据区data segment","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/blog/tags/Java/"},{"name":"Memory","slug":"Memory","permalink":"http://yoursite.com/blog/tags/Memory/"}]},{"title":"MongoDB 安装经历","slug":"MongoDB-安装经历","date":"2019-04-12T08:55:50.000Z","updated":"2019-04-12T09:08:44.087Z","comments":true,"path":"2019/04/12/MongoDB-安装经历/","link":"","permalink":"http://yoursite.com/blog/2019/04/12/MongoDB-安装经历/","excerpt":"","text":"首先判断自己的Linux系统是什么型号，可以用 lse_release 命令看, LSB代表(Linux Standard Base)。如果没有这个命令就用1cat /etc/issue 查看 Ubuntu别名和版本的信息如下 之后从这个网站https://www.mongodb.com/download-center/community?jmp=docs选择对应的.tar.gz安装包。下载完后解压。 将bin文件夹添加至PATH环境变量中编辑~/.bashrc文件，在最后一行添加1export PATH=&lt;mongodb-install-directory&gt;/bin:$PATH 之后输入如下命令更新1source ~/.bashrc 运行 mongod 前，需要创建一个文件夹用于 MongoDB 写入数据。默认情况下，MongoDB 往 /data/db文件夹中写入数据，此处我直接创建该目录：1mkdir /data/db 更改文件夹权限这里注意刚创建出来的/data/db文件夹是只读的。我们使用1chmod 777 /data/db 命令使得文件夹可以 read - 4 write - 2 execute - 1 完成然后在前台输入mongod命令即可 注意连接字符串connection string为mongodb://10.251.254.184:27017不要忘了mongodb://","categories":[],"tags":[{"name":"Database","slug":"Database","permalink":"http://yoursite.com/blog/tags/Database/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/blog/tags/MongoDB/"},{"name":"installation","slug":"installation","permalink":"http://yoursite.com/blog/tags/installation/"}]},{"title":"printf输出时%d前显示特定0","slug":"printf输出时-d前显示特定0","date":"2019-04-11T09:51:09.000Z","updated":"2019-04-11T09:53:27.177Z","comments":true,"path":"2019/04/11/printf输出时-d前显示特定0/","link":"","permalink":"http://yoursite.com/blog/2019/04/11/printf输出时-d前显示特定0/","excerpt":"","text":"printf()函数输出的时候可以用 printf(“%03d”, x); 这种方式使得比如说x == 9，那么输出009x == 15，那么输出015x == 385，那么输出385 掌握以下这个小技巧","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/blog/tags/Algorithm/"},{"name":"tricks","slug":"tricks","permalink":"http://yoursite.com/blog/tags/tricks/"}]},{"title":"软件学院本科生应该怎么学习","slug":"软件学院本科生应该怎么学习","date":"2019-04-06T01:04:53.000Z","updated":"2019-04-06T01:05:23.802Z","comments":true,"path":"2019/04/06/软件学院本科生应该怎么学习/","link":"","permalink":"http://yoursite.com/blog/2019/04/06/软件学院本科生应该怎么学习/","excerpt":"","text":"本人今年北软研究生毕业，本科是35所示范性软院之一，在毕业之际，回顾软院的7年学习生活，很感慨，写点东西给软件学院的师弟师妹们。 今年软件工程被提升至一级学科，没有挂在计算机科学之下了，而且软件学院开始招收工程博士生了，真是可喜可贺。 我读软件学院本科的时候，软院才刚成立不久，35所示范性软院之一，那个时候想找个师兄问一问大学该怎么度过，软院第一届的师兄们都还没毕业呢，也很懵懂，咋给我经验呢。只好自己摸索着学习了。现在我都软院研究生毕业了，就让我来给大家讲讲在软件学院的本科该如何学习吧。 大学本科的教育重点是基础教育，软件学院也应该是（但实际做法可能不是）。 我觉得本科就是要学习基础知识，学软件首先需做到两点： 第一、精通一门编程语言； 第二、精通算法。 做到这两点，你本科毕业就能找到不错的工作了。对与找工作，j2ee跟.net都是锦上添花的东西，利用大三的选修课，或者大三的暑假学学，大专生都只学三个月的技术，你难道要学四年吗？切不可本末倒置，得了芝麻，丢了西瓜。 大学毕业的时候，有的拿着10+w的年薪，在大公司做软件工程师，而有的连个工作也找不到。造成这些差距的原因是什么？我觉得主要在课后。大家都一起上课，你能学到的别人也能学到，而且，纸上得来终觉浅，绝知此事要躬行。课后花的功夫就形成了的差距。大学里，老师只负责教好自己的课，你课后干什么没人约束，所以，一定要安排好自己课后时间。所以，这篇文章会告诉怎么安排课后的时间。 另外，编程高手都是喜欢看书的。一定要看经典的、有营养的书，别看垃圾书。选择书籍的时候，你可去豆瓣网看看书评，买好书才能节约你的时间，看了垃圾书浪费时间。建议多看国外计算机名校的教材，国内的好书不多；编程高手一定是喜欢动手的，课后多参加编程活动。李开复曾建议计算机学生大学本科四年，应该写10w行代码。 我对我的本科时的软件学院教学方案不是很赞成。第一、教一些大而空的东西。软件学院教一些诸如软件工程的东西，对编程没有太多实际的帮助（至少以本科生的水平来看，吸收不了那么多）。计算机领域的有点难度、有技术含量的东西可能并不会教给你。可能是由于当时的软院还在摸索阶段吧。第二、喜欢重点教一些工具的使用。比如asp.net。这些都是招式，不是内功。我觉得，本科阶段学习一定是以计算机基础为核心的。第三、对学生的定位。学院把教学重点放在web编程上，培养了大量的web程序员。这些不是不能教，我的意思是，不能当做重点来教。本人也是学过j2ee的。 如果你想从事更高端的软件编程工作，对自己的要求就不能太低哦。所以，我写这篇文章主要目的是劝你往高层次看齐，做高端的软件工程师，比如：算法设计，数据挖掘，图像处理，网络应用，游戏编程，计算机安全，分布式系统设计，嵌入式系统之类的，这些要求对计算机的理解更深。 好吧，开始我的建议吧。 你大一、大二很闲吗？是的话就太危险了。我觉得这是你能不能成为编程高手的关键时期哦。如果你用两年的时间都没喜欢上编程，以后也很难喜欢上。这是你训练编程能力的最佳时期，大三再来练习，时间就有点短。如果你有大把的时间，并且迫切希望知道怎么做的话，下面的内容就是回答你的问题的。 精通一门编程语言 讲讲大一。如果你中学的时候没接触电脑，那就先练习一下打字吧，因为打字太慢会影响编程的，安装一个金山打字通，每天睡觉之前打字30分钟，坚持一个月。买个笔记本，现在笔记本便宜了，不像我上本科那会用台式机，配置的话内存至少2G，CPU频率过得去就行，价格在4-5k就可以，实在没钱就买神舟笔记本，据说有几款性价比不错。笔记本是用来写程序的，不是玩的。 大一是肯定学编程语言的，不管学的是哪门语言，都要做到精通。精通一门就好了，开始的时候别想学太多，这样对你掌握语言反而不好。我建议你学C++，因为我学这个，嘿嘿。学习C++，主要是学习面向对象的思想，还有要清楚C++是如何分配内存的，以及派生，多态，重载，虚函数，构造析构，STL等，特别关注内存泄露。如果是入门学习的话，建议你看看书籍《Essential C++》，《C++ Primer》，然后再去读读《C++编程思想》，《Effective C++》，《深入理解C++对象模型》，《设计模式》这几本书。编程环境建议使用VC++，或者Linux上的GCC。 如果你是想做java程序员的话，java就简单许多了，经典的书籍也很多，比如《Java编程思想》，自己网上搜一搜吧。 当然，大一你可能还会学其它东西，但是精通一门编程语言是你最重要的任务。 算法是软实力的体现 大二的时候，该学数据解构和算法了吧。软件学院的学生，常号称自己动手能力强，真的强吗？你听说过ACM竞赛吗？如果想证明自己动手能力强，就该去参加这个程序竞赛。搞.net，只会拖控件这也叫动手能力强？想想自己本科那会真是天真啊。 程序=数据解构+算法，这个著名的公式在很多计算机编程书籍里都出现了。可能你很多师兄还告诉你，算法不实用，毕业之后用不着，对于一般的编码人员的确是很少用到。但是，你想做到高级软件工程师，这些都是你默认要擅长的哦。还有，越好的公司，对这个要求就越高。本科、研究生毕业能直接进微软，百度的，都是算法的高手。 如果你用大二一年的时间去参加ACM竞赛，这绝对对你的职业生涯产生不可估量的影响。如果你基础好，应该从大一的下学期就参加。最好经常去北大，浙大的ACM网站做题。买几本算法书，如果是入门级别，给你推荐的书籍有：《数据解构与算法C++描述》，《算法竞赛入门经典》（刘汝佳），《编程珠玑》，提高的书籍有：《算法艺术与信息学竞赛》（刘汝佳、黄亮），《实用算法的分析与程序设计》（吴文虎、王建德）。这些书在书店或者当当网上都可以买到。如果你周围的同学有对编程感兴趣的，可以一起报名参赛ACM，这个比赛是三个人一组的。本人本科的时候，软件学院对于ACM竞赛一点也不重视，很多软院的同学不知道有这个东西的存在。我跟几个同学经常去参加比赛，虽然没获得好名次，但是对本人的编程能力有很大的提高。如果你大一大二不是很忙，又没有参加这个比赛来锻炼自己，确实有些可惜。 观察清华，上交，浙大，北大这些计算机名校，每年都有本科生在国际的ACM比赛中拿奖。在北大软件学院读研究生，我了解到北大计算机的本科生有很多都参加这个比赛，基本上每个学期都举行全校级别的比赛。北大计算机也开了ACM的相关培训课程，所以北大计算机本科生的算法实力都非同一般啊。清华计算机的吴文虎老师是国家ACM竞赛的教练，上海交大计算机也有专门的ACM培训班，今年浙大是ACM竞赛世界冠军。这说明，这些计算机名校都很看重算法吧。虽说算法不是计算机的一切，但是反应了这些院系学生的“软实力”，这跟各个学校的软件学院一比，软件学院的学生便显得“软实力”不够了。 在大一大二，计算机的基础课要好好学的，比如数据库，离散数学（学学组合数学），编译原理，操作系统原理（建议学学Linux），计算机图形学等，都是不错的课程。我本科那会，学院不很重视计算机硬件的教学，这不利于编程能力的提高。如果你的本科学院也不够重视，建议你大二的时候自己去钻研，推荐你看《深入理解计算机系统》这本书，里面介绍了很多浅显的硬件知识，世界上很多计算机名校都教这本书。 大二可能会学很多专业基础课，但是算法是重中之重。 为找工作积累技术 大三是专业课集中的一年吧。《软件工程》的本本是要读一下的，不过别报太高期望，以本科生的见识和功底很难吸收其精华，但是里面的方法论可以拿来读读，以后慢慢体会吧。可以读一读《人月神话》，《代码大全》，这都是软件工程领域巅峰之作。 如果你打算毕业之后做一个java程序员，你可以学学j2ee（主要是MVC架构），现在的参考书真多，我也就不推荐了。当然，你还得学学各个开源的框架，比较流行的有Hibernate，Spring，Struts，最好研究一下这些框架的源码（选一个来研究）。我本科那会流行这些，我好几年不搞这个了。 如果是想做.net程序员，那就简单多了，熟悉各个控件的使用。 你可能还得补充一些其他知识：比如html，javascript，ajax（jquery），css之类的；Linux服务器的搭建，Shell、Python脚本编程，mysql数据库安装备份，apache服务器、网络管理等。比较高级的一些还包括：分布式图片服务器设计，数据挖掘等。还是要看很多书，写很多程序，别限制自己的眼界，这里面有很多值得研究的课题，比如如何架构一个图片分享的网站等。 如果你还是坚持做一个C++程序员的话，太好了，跟我是一个阵营的。你可以学学MFC程序设计，这方面的书籍有《windows核心程序设计》《深入浅出MFC》。你可以考虑加上OpenCV，使用VC++搞游戏编程。如果你将来读研，会使用C++，对做科研是很有帮助的，比如做图像处理，网络编程，嵌入式等。 切不可东学一下，西学一下，不管你走哪条技术路线，要精通。 实习和就业 大四的实习和找工作。软院的学生在大四都要出去实习至少6个月吧。如果大学四年都在认真编程，毕业之后找份工作是很容易的，但是找什么样的工作才是我们关心的。我建议大家在实习的时候一定要找准。尽量去一些好点的公司实习，然后留下来，这样你就不需要再投简历笔试面试地找工作了。本人认为好点的软件公司有：腾讯，阿里巴巴，淘宝，百度，华为，人人网，盛大，网易，新浪，深信服，华为3COM，金山，金蝶，用友，toplink。深圳也有一些小的IT公司待遇也不错，这个可以自己去网上搜啦。 微软，google，intel，ibm，甲骨文，这些外企基本上都只招硕士，如果你能进入这些公司实习，得打听一下能不能留下来。 如果实习不打算留下来，就得准备参加笔试了，算法是肯定会考察的，还有就是计算机的基础知识了。总之，找工作是容易的，找个好工作才是你的目标哦。 现在大家常说程序员是IT民工，这不无道理，如果你在一家IT公司的软件生产线上干着一些不重要、重复体力的活，人家想把你换掉就换掉，那你就是IT民工。所以大家在工作中应注意学习公司的核心技术。如果你掌握了公司的核心技术，还dan？如果真那样，你可以自己出去开公司了。 另外，也有些同学想创业，本人没这方面的经验，不敢乱说，但是如果你想好了就去做吧。","categories":[],"tags":[{"name":"过来人谈学习方法","slug":"过来人谈学习方法","permalink":"http://yoursite.com/blog/tags/过来人谈学习方法/"}]},{"title":"leetcode简单 104","slug":"leetcode简单-104","date":"2019-04-05T05:56:04.000Z","updated":"2019-04-05T05:56:55.567Z","comments":true,"path":"2019/04/05/leetcode简单-104/","link":"","permalink":"http://yoursite.com/blog/2019/04/05/leetcode简单-104/","excerpt":"","text":"这个题已经写了好几遍了，就是求二叉树的高度的问题。一定要背下来。经常考。12345678910111213141516171819class Solution &#123;public: int maxDepth(TreeNode* root) &#123; // 如果root为空 if (root == NULL) &#123; return 0; &#125; if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123; return 1; &#125; return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)); &#125;&#125;;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/blog/tags/Algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/blog/tags/leetcode/"},{"name":"leetcode简单","slug":"leetcode简单","permalink":"http://yoursite.com/blog/tags/leetcode简单/"}]},{"title":"leetcode简单 237","slug":"leetcode简单-237","date":"2019-04-05T05:49:33.000Z","updated":"2019-04-05T05:51:20.136Z","comments":true,"path":"2019/04/05/leetcode简单-237/","link":"","permalink":"http://yoursite.com/blog/2019/04/05/leetcode简单-237/","excerpt":"","text":"这个题在剑指offer上出现过。就是把后一个节点的值复制到当前节点，然后把后一个节点删掉。leetcode上free的话好像会报错，就省了。代码就两行。 12345678910111213class Solution &#123;public: void deleteNode(ListNode* node) &#123; node-&gt;val = node-&gt;next-&gt;val; node-&gt;next = node-&gt;next-&gt;next; //ListNode *next= node-&gt;next; //free(next); &#125;&#125;;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/blog/tags/Algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/blog/tags/leetcode/"},{"name":"leetcode简单","slug":"leetcode简单","permalink":"http://yoursite.com/blog/tags/leetcode简单/"}]},{"title":"leetcode简单 709","slug":"leetcode简单-709","date":"2019-04-05T05:35:10.000Z","updated":"2019-04-05T05:35:54.427Z","comments":true,"path":"2019/04/05/leetcode简单-709/","link":"","permalink":"http://yoursite.com/blog/2019/04/05/leetcode简单-709/","excerpt":"","text":"这个题直接暴力循环就能过 12345678910111213141516171819class Solution &#123;public: string toLowerCase(string str) &#123; string result = \"\"; for (int i = 0; i &lt; str.size(); i++) &#123; if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z') &#123; result += ('a' + str[i] - 'A'); &#125; else &#123; result += str[i]; &#125; &#125; return result; &#125;&#125;;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/blog/tags/Algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/blog/tags/leetcode/"},{"name":"leetcode简单","slug":"leetcode简单","permalink":"http://yoursite.com/blog/tags/leetcode简单/"}]},{"title":"leetcode简单 771","slug":"leetcode简单-771","date":"2019-04-05T05:28:32.000Z","updated":"2019-04-05T05:31:15.069Z","comments":true,"path":"2019/04/05/leetcode简单-771/","link":"","permalink":"http://yoursite.com/blog/2019/04/05/leetcode简单-771/","excerpt":"","text":"暴力求解法， 两个循环，复杂度$O(n^2)$ 1234567891011121314151617181920class Solution &#123;public: int numJewelsInStones(string J, string S) &#123; int lenJ = J.size(); int lenS = S.size(); int count = 0; for (int i = 0; i &lt; lenS; i++) &#123; for (int j = 0; j &lt; lenJ; j++) &#123; if (S[i] == J[j]) &#123; count++; &#125; &#125; &#125; return count; &#125;&#125;;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/blog/tags/Algorithm/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/blog/tags/leetcode/"},{"name":"leetcode简单","slug":"leetcode简单","permalink":"http://yoursite.com/blog/tags/leetcode简单/"}]},{"title":"基础堆算法","slug":"基础堆算法","date":"2019-04-05T04:54:44.000Z","updated":"2019-04-05T04:58:08.117Z","comments":true,"path":"2019/04/05/基础堆算法/","link":"","permalink":"http://yoursite.com/blog/2019/04/05/基础堆算法/","excerpt":"","text":"1234567891011121314151617181920212223void heapify(int arr[], int n, int i) &#123; int largest = i; // Initialize largest as root int l = 2*i + 1; // left = 2*i + 1 int r = 2*i + 2; // right = 2*i + 2 // If left child is larger than root if (l &lt; n &amp;&amp; arr[l] &gt; arr[largest]) largest = l; // If right child is larger than largest so far if (r &lt; n &amp;&amp; arr[r] &gt; arr[largest]) largest = r; // If largest is not root if (largest != i) &#123; swap(arr[i], arr[largest]); // Recursively heapify the affected sub-tree heapify(arr, n, largest); &#125; &#125; 12345void buildHeap(int arr[], int n) &#123; // Build heap (rearrange array) for (int i = n / 2 - 1; i &gt;= 0; i--) heapify(arr, n, i); &#125; 123456789101112131415// main function to do heap sort void heapSort(int arr[], int n) &#123; buildHeap(arr, n); // One by one extract an element from heap for (int i=n-1; i&gt;=0; i--) &#123; // Move current root to end swap(arr[0], arr[i]); // call max heapify on the reduced heap heapify(arr, i, 0); &#125; &#125; 掌握了这3段程序就能写出堆排序的程序了。","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/blog/tags/Algorithm/"},{"name":"heap","slug":"heap","permalink":"http://yoursite.com/blog/tags/heap/"}]},{"title":"binary search template","slug":"binary-search-template","date":"2019-04-04T05:28:21.000Z","updated":"2019-04-04T07:34:56.543Z","comments":true,"path":"2019/04/04/binary-search-template/","link":"","permalink":"http://yoursite.com/blog/2019/04/04/binary-search-template/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: /** * @param nums: The integer array. * @param target: Target to find. * @return: The first position of target. Position starts from 0. */ int binarySearch(vector&lt;int&gt; &amp;nums, int target) &#123; // write your code here if (nums.size() == 0) &#123; return -1; &#125; int start = 0; int end = nums.size() - 1; int mid; while (start + 1 &lt; end) &#123; mid = start + (end - start) / 2; if (nums[mid] == target) &#123; end = mid; &#125; else if (nums[mid] &lt; target) &#123; start = mid; &#125; else if (nums[mid] &gt; target) &#123; end = mid; &#125; &#125; if (nums[start] == target) &#123; return start; &#125; if (nums[end] == target) &#123; return end; &#125; return -1; &#125;&#125;;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/blog/tags/Algorithm/"},{"name":"二分查找","slug":"二分查找","permalink":"http://yoursite.com/blog/tags/二分查找/"},{"name":"模板","slug":"模板","permalink":"http://yoursite.com/blog/tags/模板/"}]},{"title":"class Solution {","slug":"class-Solution","date":"2019-04-04T05:27:59.000Z","updated":"2019-04-04T05:27:59.244Z","comments":true,"path":"2019/04/04/class-Solution/","link":"","permalink":"http://yoursite.com/blog/2019/04/04/class-Solution/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-04-04T04:28:25.009Z","updated":"2019-04-08T06:53:33.245Z","comments":true,"path":"2019/04/04/hello-world/","link":"","permalink":"http://yoursite.com/blog/2019/04/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"print char if not told how many","slug":"print-char-if-not-told-how-many","date":"2019-04-03T09:21:37.000Z","updated":"2019-04-04T04:37:24.908Z","comments":true,"path":"2019/04/03/print-char-if-not-told-how-many/","link":"","permalink":"http://yoursite.com/blog/2019/04/03/print-char-if-not-told-how-many/","excerpt":"","text":"链接：https://ac.nowcoder.com/acm/problem/22224来源：牛客网 题目描述输入一行字符串，原样输出这个字符串。 输入描述:输入一行，包含一个字符串。输出描述:输出一个字符串。示例1输入复制oi er输出复制oi er 1234567891011121314#include &lt;cstdio&gt;#include &lt;cstring&gt;int main() &#123; // freopen(\"input.txt\", \"r\", stdin); int c; while ((c = getchar()) != EOF) &#123; printf(\"%c\", c); &#125; return 0;&#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/blog/tags/Algorithm/"},{"name":"NOIP普及组","slug":"NOIP普及组","permalink":"http://yoursite.com/blog/tags/NOIP普及组/"}]},{"title":"输出金字塔图形","slug":"输出金字塔图形","date":"2019-04-01T06:06:23.000Z","updated":"2019-04-01T06:14:26.000Z","comments":true,"path":"2019/04/01/输出金字塔图形/","link":"","permalink":"http://yoursite.com/blog/2019/04/01/输出金字塔图形/","excerpt":"","text":"这种题应该先想办法输出 * * * * * * * * * * * * * * * * * * * * * * * * * 这种靠一边的，然后再加空格变成 * * * * * * * * * * * * * * * * * * * * * * * * * 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;int main() &#123; //freopen(\"input.txt\", \"r\", stdin); int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; /*for (int j = 0; j &lt; n - i - 1; j++) &#123; printf(\" \"); &#125;*/ for (int j = 0; j &lt; n - i - 1; j++) &#123; printf(\" \"); &#125; for (int j = 0; j &lt;2 * i + 1; j++) &#123; printf(\"*\"); &#125; printf(\"\\n\"); &#125; return 0;&#125; 如果是输出双层金字塔 * *** ***** ******* ********* ******* ***** *** * 那么我们先输出 * * * * * * * * * * * * * * * * * * * * * * * * * 然后再输出 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 然后再增加空格 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 然后稍微改一下就可以变成目标形状 * *** ***** ******* ********* ******* ***** *** * 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;int main() &#123; //freopen(\"input.txt\", \"r\", stdin); int n; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n - i - 1; j++) &#123; printf(\" \"); &#125; for (int j = 0; j &lt;2 * i + 1; j++) &#123; printf(\"*\"); &#125; printf(\"\\n\"); &#125; for (int i = n - 2; i &gt; -1; i--) &#123; for (int j = 0; j &lt; n - i - 1; j++) &#123; printf(\" \"); &#125; for (int j = 0; j &lt;2 * i + 1; j++) &#123; printf(\"*\"); &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"Algorithm NOIP普及组","slug":"Algorithm-NOIP普及组","permalink":"http://yoursite.com/blog/tags/Algorithm-NOIP普及组/"}]},{"title":"选村长","slug":"选村长","date":"2019-04-01T05:34:29.000Z","updated":"2019-04-01T05:36:15.000Z","comments":true,"path":"2019/04/01/选村长/","link":"","permalink":"http://yoursite.com/blog/2019/04/01/选村长/","excerpt":"","text":"题目描述牛村正在进行村长选举，投票人一人一票，牛可乐是候选人A（投票代号为1）、牛能是候选人B（投票代号为2）和牛妹是候选人C（投票代号为3），其他投票代号无效。投票列表用以-1表示结束，请分别统计出他们的得票数。谁的得票超过全部投票人数的半数，就输出谁当选为村长，如“A-yes”表示A当选，全部不过半数，输出“all-NO”。 输入描述:输入一行，若干个整数，以-1结尾 输出描述:输出五行，前三行表示三个候选人的表票数，然后是总的有效票数，最后一行表示选举结果。 示例输入 1 1 3 2 1 3 2 1 3 3 1 2 4 1 4 1 2 1 2 1 1 -1 输出 A=10 B=5 C=4 Tot=19 all-NO 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cmath&gt;int main() &#123;// freopen(\"input.txt\", \"r\", stdin); int c; int A = 0, B = 0, C = 0, Tot = 0; while ((c = getchar()) != '-') &#123; //printf(\"%c\", c); if (c == '1') &#123; A += 1; Tot += 1; &#125; if (c == '2') &#123; B += 1; Tot += 1; &#125; if (c == '3') &#123; C += 1; Tot += 1; &#125; &#125; printf(\"A=%d\\n\", A); printf(\"B=%d\\n\", B); printf(\"C=%d\\n\", C); printf(\"Tot=%d\\n\", Tot); if (A &gt; ceil(Tot / 2.0)) &#123; printf(\"A-yes\\n\"); &#125; else if (B &gt; ceil(Tot / 2.0)) &#123; printf(\"B-yes\\n\"); &#125; else if (C &gt; ceil(Tot / 2.0)) &#123; printf(\"C-yes\\n\"); &#125; else &#123; printf(\"all-NO\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"Algorithm NOIP普及组","slug":"Algorithm-NOIP普及组","permalink":"http://yoursite.com/blog/tags/Algorithm-NOIP普及组/"}]},{"title":"n元人民币换成1元2元5元的零钱共有多少种兑换方法","slug":"n元人民币换成1元2元5元的零钱共有多少种兑换方法","date":"2019-04-01T04:57:31.000Z","updated":"2019-04-04T05:01:44.549Z","comments":true,"path":"2019/04/01/n元人民币换成1元2元5元的零钱共有多少种兑换方法/","link":"","permalink":"http://yoursite.com/blog/2019/04/01/n元人民币换成1元2元5元的零钱共有多少种兑换方法/","excerpt":"","text":"链接：https://ac.nowcoder.com/acm/problem/22214来源：牛客网 牛可乐在牛牛商场买了一个帽子，要支付c元金币，牛牛商场一律不找零钱，牛可乐手里有不限数量的面值a元的金币和面值b元的金币，请问牛可乐可以用金币刚好凑出总价c元吗？ 123456789101112131415161718192021#include &lt;cstdio&gt;int main() &#123; int n; scanf(\"%d\", &amp;n); int sum = 0; for (int i = 0; i &lt;= n / 2; i++) &#123; for (int j = 0; j &lt;= n / 5; j++) &#123; if (n - i * 2 - j * 5 &gt;= 0) &#123; sum += 1; &#125; &#125; &#125; printf(\"%d\\n\", sum); return 0;&#125; 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cmath&gt;int Is(int a, int b, int c) &#123; int ceilA = ceil(c * 1.0 / a); int ceilB = ceil(c * 1.0 / b); for (int i = 0; i &lt;= ceilA; i++) &#123; for (int j = 0; j &lt;= ceilB; j++) &#123; if (i * a + j * b == c) &#123; return 1; &#125; &#125; &#125; return 0;&#125;int main() &#123; int a, b, c; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); if (Is(a, b, c)) &#123; printf(\"Yes\\n\"); &#125; else &#123; printf(\"No\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/blog/tags/Algorithm/"},{"name":"NOIP普及组","slug":"NOIP普及组","permalink":"http://yoursite.com/blog/tags/NOIP普及组/"}]},{"title":"Sum of all proper divisors of a natural number","slug":"Sum-of-all-proper-divisors-of-a-natural-number","date":"2019-04-01T04:50:22.000Z","updated":"2019-04-01T06:45:27.000Z","comments":true,"path":"2019/04/01/Sum-of-all-proper-divisors-of-a-natural-number/","link":"","permalink":"http://yoursite.com/blog/2019/04/01/Sum-of-all-proper-divisors-of-a-natural-number/","excerpt":"","text":"Given a natural number, calculate sum of all its proper divisors. A proper divisor of a natural number is the divisor that is strictly less than the number. For example, number 20 has 5 proper divisors: 1, 2, 4, 5, 10, and the divisor summation is: 1 + 2 + 4 + 5 + 10 = 22. Examples : Input : num = 10 Output: 8 // proper divisors 1 + 2 + 5 = 8 Input : num = 36 Output: 55 // proper divisors 1 + 2 + 3 + 4 + 6 + 9 + 12 + 18 = 55 This problem has very simple solution, we all know that for any number ‘num’ all its divisors are always less than and equal to ‘num/2’ and all prime factors are always less than and equal to sqrt(num). So we iterate through ‘i’ till i&lt;=sqrt(num) and for any ‘i’ if it divides ‘num’ , then we get two divisors ‘i’ and ‘num/i’ , continuously add these divisors but for some numbers divisors ‘i’ and ‘num/i’ will same in this case just add only one divisor , e.g; num=36 so for i=6 we will get (num/i)=6 , that’s why we will at 6 in the summation only once. Finally we add one as one is divisor of all natural numbers. 1234567891011121314151617181920212223242526272829303132333435363738// C++ program to find sum of all divisors of // a natural number #include&lt;bits/stdc++.h&gt; using namespace std; // Function to calculate sum of all proper divisors // num --&gt; given natural number int divSum(int num) &#123; // Final result of summation of divisors int result = 0; // find all divisors which divides 'num' for (int i=2; i&lt;=sqrt(num); i++) &#123; // if 'i' is divisor of 'num' if (num%i==0) &#123; // if both divisors are same then add // it only once else add both if (i==(num/i)) result += i; else result += (i + num/i); &#125; &#125; // Add 1 to the result as 1 is also a divisor return (result + 1); &#125; // Driver program to run the case int main() &#123; int num = 36; cout &lt;&lt; divSum(num); return 0; &#125; 牛村村口要架设一个矩形的广告屏，村长要求广告屏的总像素必须为n，还要求广告屏的长和宽最大可能的接近，而且宽不能大于长，村长找你来计算一下宽和长分别为多少？ 1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = sqrt(n); i &gt;= 1; i--) &#123; if (n % i == 0) &#123; printf(\"%d %d\\n\", i, n / i); break; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"Algorithm NOIP普及组","slug":"Algorithm-NOIP普及组","permalink":"http://yoursite.com/blog/tags/Algorithm-NOIP普及组/"}]},{"title":"能被3整除且至少有一位数字是5","slug":"能被3整除且至少有一位数字是5","date":"2019-04-01T04:37:15.000Z","updated":"2019-04-01T04:38:47.000Z","comments":true,"path":"2019/04/01/能被3整除且至少有一位数字是5/","link":"","permalink":"http://yoursite.com/blog/2019/04/01/能被3整除且至少有一位数字是5/","excerpt":"","text":"题目描述输出1~n中能被3整除，且至少有一位数字是5的所有整数. 输入描述:输入一行，包含一个整数n。(1 &lt;= n &lt;= 100000) 示例1输入 50 输出 15 45 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;int main() &#123; int n; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int gewei = i % 10; int shiwei = (i / 10) % 10; int baiwei = (i / 100) % 10; int qianwei = (i / 1000) % 10; int wanwei = (i / 10000) % 10; int shiwanwei = (i / 100000) % 10; if ( (i % 3 == 0) &amp;&amp; ( gewei == 5 || shiwei == 5 || baiwei == 5 || qianwei == 5 || wanwei == 5 || shiwanwei == 5 ) ) &#123; printf(\"%d\\n\", i); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"Algorithm NOIP普及组","slug":"Algorithm-NOIP普及组","permalink":"http://yoursite.com/blog/tags/Algorithm-NOIP普及组/"}]},{"title":"判断回文数","slug":"判断回文数","date":"2019-04-01T04:27:08.000Z","updated":"2019-04-01T04:28:57.000Z","comments":true,"path":"2019/04/01/判断回文数/","link":"","permalink":"http://yoursite.com/blog/2019/04/01/判断回文数/","excerpt":"","text":"判断一个数是否为回文数。 设n是一任意自然数。若将n的各位数字反向排列所得自然数n1与n相等，则称n为一回文数。例如，若n=1234321，则称n为一回文数；但若n=1234567，则n不是回文数 实例 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt; int main()&#123; int n, reversedInteger = 0, remainder, originalInteger; printf(\"输入一个整数: \"); scanf(\"%d\", &amp;n); originalInteger = n; // 翻转 while( n!=0 ) &#123; remainder = n%10; reversedInteger = reversedInteger*10 + remainder; n /= 10; &#125; // 判断 if (originalInteger == reversedInteger) printf(\"%d 是回文数。\", originalInteger); else printf(\"%d 不是回文数。\", originalInteger); return 0;&#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/blog/tags/Algorithm/"}]},{"title":"判断数字是几位数","slug":"判断数字是几位数","date":"2019-04-01T04:13:54.000Z","updated":"2019-04-01T04:29:08.000Z","comments":true,"path":"2019/04/01/判断数字是几位数/","link":"","permalink":"http://yoursite.com/blog/2019/04/01/判断数字是几位数/","excerpt":"","text":"用户输入数字，判断该数字是几位数。 实例 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; long long n; int count = 0; printf(\"输入一个整数: \"); scanf(\"%lld\", &amp;n); while(n != 0) &#123; // n = n/10 n /= 10; ++count; &#125; printf(\"数字是 %d 位数。\", count);&#125;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/blog/tags/Algorithm/"}]},{"title":"Greatest Common Divisor Algorithm","slug":"Greatest-Common-Divisor-Algorithm-md","date":"2019-03-30T19:20:24.000Z","updated":"2019-03-30T19:36:07.000Z","comments":true,"path":"2019/03/31/Greatest-Common-Divisor-Algorithm-md/","link":"","permalink":"http://yoursite.com/blog/2019/03/31/Greatest-Common-Divisor-Algorithm-md/","excerpt":"","text":"Greatest Common Divisor Algorithm#include &lt;cstdio&gt; int gcd(int a, int b) { int c = a % b; if (c != 0) { return gcd(b, c); } else { return b; } } int main() { int a, b; scanf(\"%d %d\", &amp;a, &amp;b); if (a &gt;= b) { printf(\"%d\\n\", gcd(a, b)); } else { printf(\"%d\\n\", gcd(b, a)); } return 0; }","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/blog/tags/Algorithm/"}]},{"title":"Whether a binary tree is balanced or not.md","slug":"Whether-a-binary-tree-is-balanced-or-not-md","date":"2019-03-30T18:40:55.000Z","updated":"2019-03-30T18:51:43.000Z","comments":true,"path":"2019/03/31/Whether-a-binary-tree-is-balanced-or-not-md/","link":"","permalink":"http://yoursite.com/blog/2019/03/31/Whether-a-binary-tree-is-balanced-or-not-md/","excerpt":"","text":"Whether a binary tree is balanced or notThe definition of a balanced binary tree is : left sub-tree is balanced &amp;&amp; right sub-tree is balanced &amp;&amp; abs(height(left) - height(right)) &lt;= 1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/* CPP program to check if a tree is height-balanced or not */#include &lt;bits/stdc++.h&gt; using namespace std; /* A binary tree node has data, pointer to left child and a pointer to right child */class node &#123; public: int data; node* left; node* right; &#125;; /* Returns the height of a binary tree */int height(node* node); /* Returns true if binary tree with root as root is height-balanced */bool isBalanced(node *root) &#123; int lh; /* for height of left subtree */ int rh; /* for height of right subtree */ /* If tree is empty then return true */ if(root == NULL) return 1; /* Get the height of left and right sub trees */ lh = height(root-&gt;left); rh = height(root-&gt;right); if( abs(lh-rh) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right)) return 1; /* If we reach here then tree is not height-balanced */ return 0; &#125; /* UTILITY FUNCTIONS TO TEST isBalanced() FUNCTION *//* returns maximum of two integers */int max(int a, int b) &#123; return (a &gt;= b)? a: b; &#125; /* The function Compute the \"height\" of a tree. Height is the number of nodes along the longest path from the root node down to the farthest leaf node.*/int height(node* node) &#123; /* base case tree is empty */ if(node == NULL) return 0; /* If tree is not empty then height = 1 + max of left height and right heights */ return 1 + max(height(node-&gt;left), height(node-&gt;right)); &#125; /* Helper function that allocates a new node with the given data and NULL left and right pointers. */node* newNode(int data) &#123; node* Node = new node(); Node-&gt;data = data; Node-&gt;left = NULL; Node-&gt;right = NULL; return(Node); &#125; // Driver code int main() &#123; node *root = newNode(1); root-&gt;left = newNode(2); root-&gt;right = newNode(3); root-&gt;left-&gt;left = newNode(4); root-&gt;left-&gt;right = newNode(5); root-&gt;left-&gt;left-&gt;left = newNode(8); if(isBalanced(root)) cout &lt;&lt; \"Tree is balanced\"; else cout &lt;&lt; \"Tree is not balanced\"; return 0; &#125; // This code is contributed by rathbhupendra","categories":[],"tags":[]},{"title":"How to publish my writing.md","slug":"How-to-publish-my-writing-md","date":"2019-03-30T18:32:34.000Z","updated":"2019-03-30T19:00:02.000Z","comments":true,"path":"2019/03/31/How-to-publish-my-writing-md/","link":"","permalink":"http://yoursite.com/blog/2019/03/31/How-to-publish-my-writing-md/","excerpt":"","text":"How to Publish My Writing Next TimeFirst, type in 1sudo hexo new \"How to * .md\" then in folder /source/_posts/ we can see our newly generated markdown file. Then open and edit it. After editing, type in 1sudo hexo clean &amp;&amp; hexo g g standards for generate Then in order to preview, we can type in 1sudo hexo server -p 8080 p standards for port then we can preview in our browser. If it is ok, we can type in 1sudo hexo d d standards for deploy to publish it.","categories":[],"tags":[]}]}